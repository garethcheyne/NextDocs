# Production Docker Compose Configuration
# Usage: docker-compose -f docker-compose.prod.yml up -d

services:
  # Next.js application (production by default, can be overridden for development)
  app:
    env_file:
      - .env
    build:
      context: .
      dockerfile: Dockerfile
      target: runner
      args:
        - NEXT_PUBLIC_VAPID_PUBLIC_KEY=${NEXT_PUBLIC_VAPID_PUBLIC_KEY}
    image: nextdocs-app:latest
    container_name: nextdocs-app-prod
    ports:
      - "8101:8100"
    environment:
      - NODE_ENV=${NODE_ENV:-production}
      - DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/nextdocs
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
      - NEXTAUTH_URL=${NEXTAUTH_URL:-https://docs.harveynorman.com}
      - NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
      - AUTH_TRUST_HOST=${AUTH_TRUST_HOST:-true}
      - ENCRYPTION_KEY=${ENCRYPTION_KEY}
      - AZURE_AD_CLIENT_ID=${AZURE_AD_CLIENT_ID}
      - AZURE_AD_CLIENT_SECRET=${AZURE_AD_CLIENT_SECRET}
      - AZURE_AD_TENANT_ID=${AZURE_AD_TENANT_ID}
      - BACKUP_DIR=/backups
    volumes:
      - ./backups:/backups:rw
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - nextdocs-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:8100/api/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          memory: 2G
        reservations:
          memory: 512M

  # PostgreSQL database with backup volume
  postgres:
    env_file:
      - .env
    image: postgres:16-alpine
    container_name: nextdocs-postgres-prod
    ports:
      - "5501:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=nextdocs
      - PGDATA=/var/lib/postgresql/data/pgdata
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./backups:/backups
      - ./scripts/postgres-init.sh:/docker-entrypoint-initdb.d/init.sh:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d nextdocs"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - nextdocs-network
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 256M

  # Redis for caching and sessions
  redis:
    env_file:
      - .env
    image: redis:7-alpine
    container_name: nextdocs-redis-prod
    ports:
      - "6401:6379"
    volumes:
      - redis-data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 5s
    networks:
      - nextdocs-network
    restart: unless-stopped
    command: >
      redis-server
      --appendonly yes
      --requirepass ${REDIS_PASSWORD}
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 128M

  # Unified scheduled tasks service (backups + maintenance)
  cron-tasks:
    build:
      context: .
      dockerfile: Dockerfile
      target: runner
    image: nextdocs-app:latest
    container_name: nextdocs-cron-tasks
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/nextdocs
      - POSTGRES_HOST=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=nextdocs
      - BACKUP_RETENTION_DAYS=${BACKUP_RETENTION_DAYS:-7}
      - BACKUP_HOURLY_RETENTION_HOURS=${BACKUP_HOURLY_RETENTION_HOURS:-24}
    volumes:
      - ./backups:/backups
      - ./scripts/cron-tasks:/cron-tasks:ro
    networks:
      - nextdocs-network
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped
    user: root
    command: >
      sh -c '
      echo "Setting up unified cron tasks service..." &&
      apk add --no-cache postgresql-client &&
      mkdir -p /var/log /usr/local/bin &&
      cp /cron-tasks/*.sh /usr/local/bin/ &&
      chmod +x /usr/local/bin/*.sh &&
      echo "Running initial backup..." &&
      /usr/local/bin/backup-cron.sh &&
      echo "Starting scheduled tasks loop..." &&
      while true; do
        HOUR=$(date +%H);
        echo "Running hourly tasks at $(date)" | tee -a /var/log/cron-tasks.log;
        /usr/local/bin/backup-cron.sh >> /var/log/backup.log 2>&1;
        if [ "$HOUR" = "03" ]; then
          echo "Running daily maintenance at $(date)";
          node scripts/clear-sessions.js >> /var/log/maintenance.log 2>&1;
        fi;
        sleep 3600;
      done
      '
    deploy:
      resources:
        limits:
          memory: 256M

  # Prisma Studio for database management
  studio:
    image: node:20-alpine
    container_name: nextdocs-studio
    working_dir: /app
    ports:
      - "5555:5555"
    environment:
      - DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/nextdocs?schema=public
    volumes:
      - ./prisma:/app/prisma:ro
      - ./package.json:/app/package.json:ro
    command: >
      sh -c "
      npm install -g prisma@6.19.0 &&
      prisma studio --port 5555 --hostname 0.0.0.0
      "
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - nextdocs-network
    restart: unless-stopped
    profiles:
      - studio

volumes:
  postgres-data:
    driver: local
    name: nextdocs-postgres-data
  redis-data:
    driver: local
    name: nextdocs-redis-data

networks:
  nextdocs-network:
    driver: bridge
    name: nextdocs-network
